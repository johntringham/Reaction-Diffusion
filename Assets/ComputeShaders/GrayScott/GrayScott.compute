// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSResetGrid
#pragma kernel CSResetGridToCircle

#include "..\..\Compute\NoiseInclude.compute"

int TexSize;
float Radius;

float3 laplacian[3];

float Kill;
float Feed;
float ADiffusionRate;
float BDiffusionRate;

float DeltaTime;

struct GrayScottStruct {
    float A;
    float B;
};

RWStructuredBuffer<GrayScottStruct> Current;
RWStructuredBuffer<GrayScottStruct> Prev;

RWTexture2D<float4> Bitmap;

GrayScottStruct GetValue(int2 position){
    int x = (position.x + TexSize) % TexSize;
    int y = (position.y + TexSize) % TexSize;
    return Prev[x + (y * TexSize)];
}

float2 GetValueAsFloat2(int2 position){
    GrayScottStruct val = GetValue(position);
    return float2(val.A, val.B);
}

void SetValue(int2 position, float a, float b){
    // can be optimised

    a = clamp(a, 0, 1);
    b = clamp(b, 0, 1);

    Current[position.x + (position.y) * TexSize].A = a;
    Current[position.x + (position.y) * TexSize].B = b;

	float val = abs(a - b);
    Bitmap[position.xy] = float4(val, val, val, 1);
}

[numthreads(8, 8, 1)]
void CSResetGrid(uint3 id : SV_DispatchThreadID)
{
    float2 distanceFromCenter = float2((TexSize * 0.5) - id.x, (TexSize * 0.5) - id.y);

    if(abs(distanceFromCenter.x) < Radius &&  abs(distanceFromCenter.y) < Radius){
        SetValue(id.xy, 1, 0);
    }else{
        SetValue(id.xy, 1, 1);
    }
}

[numthreads(8, 8, 1)]
void CSResetGridToCircle(uint3 id : SV_DispatchThreadID)
{
    float2 distanceFromCenter = float2((TexSize * 0.5) - id.x, (TexSize * 0.5) - id.y);

    if(length(distanceFromCenter) < Radius){
        SetValue(id.xy, 1, 0);
    }else{
        SetValue(id.xy, 1, 1);
    }
}


float2 convolve(int2 position)
{
    return (GetValueAsFloat2(position.xy + int2(-1, -1)) * laplacian[0][0]) +
           (GetValueAsFloat2(position.xy + int2(-1, 0) ) * laplacian[0][1]) +
           (GetValueAsFloat2(position.xy + int2(-1, 1) ) * laplacian[0][2]) +
           (GetValueAsFloat2(position.xy + int2(0, -1) ) * laplacian[1][0]) +
           (GetValueAsFloat2(position.xy + int2(0, 0)  ) * laplacian[1][1]) +
           (GetValueAsFloat2(position.xy + int2(0, 1)  ) * laplacian[1][2]) +
           (GetValueAsFloat2(position.xy + int2(1, -1) ) * laplacian[2][0]) +
           (GetValueAsFloat2(position.xy + int2(1, 0)  ) * laplacian[2][1]) +
           (GetValueAsFloat2(position.xy + int2(1, 1)  ) * laplacian[2][2]);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    int j = id.y;

    GrayScottStruct spot = GetValue(int2(i,j));

    float a = spot.A;
    float b = spot.B;

    float2 laplace = convolve(id.xy);
    float laplaceA = laplace.x;
    float laplaceB = laplace.y;

    float newA = a + (ADiffusionRate*laplaceA - a*b*b + Feed*(1.0-a))*1.0;
    float newB = b + (BDiffusionRate*laplaceB + a*b*b - (Kill+Feed)*b)*1.0;

    if(newA > 1.0){
        newA = 1.0;
    }
    if(newA < 0.0){
        newA = 0.0;
    }

    if(newB > 1.0){
        newB = 1.0;
    }
    if(newB < 0.0){
        newB = 0.0;
    }

    SetValue(id.xy, newA, newB);
}
